---
title: Dynamic Linking, GOTs, and PLTs 
description: Sharing what I learned about how dynamic linking works. 
date: 2024-04-16
isTodayLearned: true
tags:
  - Systems
layout: layouts/post.njk
eleventyExcludeFromCollections: true
---

I was wondering how exactly the linker pulled in libraries that we referred to in our code, as I
was writing an `ncurses` library and wanted to know what kinds of things I needed to look out for.
I didn't want to accidentally do something weird or strange if (on some rare chance) somebody
decided to use the library after all! Also, I was curious what that really strange `-fPIC` flag I was
passing to my compiler was for.

As is usually the case, it turns out that there is a lot that goes on behind the scenes that most
programmers probably take for granted.

<table-of-contents></table-of-contents>

## What is Linking?

Wikipedia has a good definition, so I'll just quote it here:

<blockquote>
<p>
In computing, a linker or link editor is a computer system program that takes one or more object
files (generated by a compiler or an assembler) and combines them into a single executable file,
library file, or another "object" file.
</p>
</blockquote>

\- [Linker (Computing)](https://en.wikipedia.org/wiki/Linker_(computing))

For example, let's say we have a simple Hello World program:

```c
#include <stdio.h>
int main(void) {
    printf("Hello World!");
}
```

When we run this program, the `printf` has to come from somewhere, right? When we call `clang main.c`, how
is the compiler able to resolve the definition of `printf`? That's the job of the linker! Saving the
details for the next section, the linker is responsible for finding the definition of `printf`,
either at compile time or run time, so the code knows what to do.

For example, if you ever get an error that looks something like this:

```text
$ clang main.c
/usr/bin/ld: /tmp/main-3c325e.o: in function `main':
main.c:(.text+0x17): undefined reference to `initscr'
/usr/bin/ld: main.c:(.text+0x1c): undefined reference to `cbreak'
.
.
.
usr/bin/ld: main.c:(.text+0x253): undefined reference to `wrefresh'
/usr/bin/ld: main.c:(.text+0x25c): undefined reference to `delwin'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

That's the linker complaining that it wasn't able to find the definition for the listed functions!
In this particular case, we needed to tell the linker that we were compiling against ncurses, and
so we would have to pass the flag `-lncurses` so the linker knows what to look for.

## Static Linking

Static linking is what happens when we link our dependencies at *compile time*.
By default, it seems like `gcc` and `clang` do dynamic linking rather than static linking,
so if you want to link your code statically you'll need to pass the `-static` flag.

To give a brief overview, dynamic linking will link dependencies at runtime, rather than
compile time. One advantage of this is that dynamically linked binaries will be much, much
smaller than statically linked libraries! It's very interesting to compare the sizes of
a statically linked and dynamically linked hello world program:

```text
$ clang main.c
$ ls -lh a.out
    -rwxrwxr-x 1 sayan sayan 16K Apr 16 20:21 a.out
$ clang main.c -static
$ ls -lh a.out
    -rwxrwxr-x 1 sayan sayan 883K Apr 16 20:21 a.out
```

Personally, I never expected statically linking a hello world program to make it as large
as 900KB! By running `nm a.out`, it seems like the entire standard library was inserted
into the executable, not just the `printf` function that the code actually uses.

This shows one problem with static linking - if every binary was static linked, then we
would have a lot of extremely big binaries with duplicated code, wouldn't we?

## Dynamic Linking

Dynamic linking, as previously mentioned, is what happens when we instead link our dependencies at
*run time*. In other words, even after compiling the executable, external references are not
resolved when using dynamic linking. We can verify this using the `nm` utility, which will show
a `U` next to unresolved symbols:

```text
$ clang main.c
$ nm a.out | grep "printf"
                 U printf@GLIBC_2.2.5

$ clang main.c -static
$ nm a.out | grep -w "printf"
000000000040b4f0 T printf
```

Notice how when we call `nm` on the statically linked binary, we get a `T` next to the printf
symbol instead, which means that the utility successfully found the symbol in the text section.
The utility even showed us the location where it can be located!

Anyway, since the symbol in the dynamically linked binary is unresolved after compiling,
we'll need a way to link `printf` during runtime instead. That happens thanks to a mysterious
object file linked into our executable, which we can find using `ldd`:

```text
$ ldd a.out
	linux-vdso.so.1 (0x00007ffc2976f000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x0000760417600000)
	/lib64/ld-linux-x86-64.so.2 (0x000076041796c000)
```

Looking up the manpage for the object `ld-linux` teaches us that it's the program that looks
up and loads shared libraries into our executable - in other words, it's our program's 
dynamic linker.

<aside>
As an aside: if you're curious, like I was, about what the <code>linux-vdso</code> object does, you'll 
probably find the <a href="https://man7.org/linux/man-pages/man7/vdso.7.html"><code>vdso</code> manpage</a> 
interesting.
</aside>

## The GOT (Global Offset Table)

## The PLT (Procedural Linkage Table)

## Observing the GOT and PLT in Action

## References
- [The Linux Programming Interface](https://man7.org/tlpi/)
- [ld-linux(8) Linux man page](https://linux.die.net/man/8/ld-linux)
- [PIC GOT PLT OMG: how does the procedure linkage table work in linux?](https://www.youtube.com/watch?v=Ss2e6JauS0Y)
